<!DOCTYPE html>
<html lang="en-US">

<head>  
  <meta charset="UTF-8">
  <meta name="description" content="Real-world test comparison of LispBM vs Guile 3 quasiquotation implementations. See test cases with color-coded results showing exact matches, semantic equivalence, and behavioral differences based on Bawden's quasiquotation algorithms.">
  <meta name="keywords" content="lispbm vs guile, quasiquotation comparison, bawden quasiquotation, lispbm testing, guile 3 Scheme, unquote splice, continuation passing style, lisp macro expansion, r5rs compliance, embedded lisp, microcontroller lisp, semantic equivalence, lisp implementation"
  <meta name="author" content="Bo Joel Svensson">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <!-- SEO Meta Tags -->
  <link rel="canonical" href="https://www.lispbm.com/quasiquotation-comparison.html">
  <meta name="robots" content="index, follow">
  
  <!-- Open Graph Meta Tags -->
  <meta property="og:title" content="LispBM vs Guile 3: Real Quasiquotation Test Results">
  <meta property="og:description" content="Real-world test comparison of LispBM vs Guile 3 quasiquotation implementations. See test cases with color-coded results showing exact matches, semantic equivalence, and behavioral differences based on Bawden's quasiquotation algorithms."
  <meta property="og:image" content="https://www.lispbm.com/images/lispbm_llama_small.png">
  <meta property="og:url" content="https://www.lispbm.com/quasiquotation-comparison.html">
  <meta property="og:type" content="website">
  <meta property="og:site_name" content="LispBM">
  
  <!-- Twitter Card Meta Tags -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="LispBM vs Guile 3: Real Quasiquotation Test Results">
  <meta name="twitter:description" content="Real-world test comparison of LispBM vs Guile 3 quasiquotation implementations. See test cases with color-coded results showing exact matches, semantic equivalence, and behavioral differences."
  <meta name="twitter:image" content="https://www.lispbm.com/images/lispbm_llama_small.png">

  <!-- Favicon and Icon Links -->
  <link rel="apple-touch-icon" sizes="180x180" href="./ico/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="./ico/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="./ico/favicon-16x16.png">
  <link rel="shortcut icon" href="./ico/favicon.ico">
  <link rel="icon" type="image/vnd.microsoft.icon" href="./ico/favicon.ico">
  <link rel="icon" type="image/x-icon" href="./ico/favicon.ico">
  <link rel="icon" href="./ico/favicon.ico">
  <link rel="manifest" href="./ico/site.webmanifest">
  
  <!-- Main Stylesheet -->
  <link rel="stylesheet" href="styles.css">
  
  <!-- Page-Specific Styles -->
  <style type="text/css">
    /* Color variables for test results */
    :root {
      --match-color: #80c080;
      --semantic-match-color: #99ccff;
      --differ-color: #f0a0a0;
      --lispbm-header-color: #2c2c2c;
      --guile-header-color: #2c2c2c;
    }
    
    /* Override centered text alignment from main stylesheet */
    .description {
      text-align: left;
    }
    
    .main-title {
      text-align: left;
    }
    
    .side-by-side {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin: 30px 0;
    }
    
    .code-section {
      margin: 0;
    }
    
    .code-header {
      font-weight: bold;
      margin-bottom: 0;
      padding: 8px 15px;
      border-radius: 5px 5px 0 0;
    }
    
    .lispbm-header {
      background: #d4edda;
      color: #155724;
      border: 1px solid #c3e6cb;
      border-bottom: none;
    }
    
    .guile-header {
      background: #f8d7da;
      color: #721c24;
      border: 1px solid #f5c6cb;
      border-bottom: none;
    }
    
    /* Adjust pre styling for side-by-side */
    .side-by-side pre {
      margin: 0 !important;
      border-radius: 0 0 5px 5px !important;
    }
    
    @media (max-width: 768px) {
      .side-by-side {
        grid-template-columns: 1fr;
        gap: 30px;
      }
    }
  </style>
</head> 

<title>LispBM vs Scheme R5RS: Quasiquotation Comparison</title>

<body class="with-background">

<div class="container">
  <div class="banner"></div>
  <a href="index.html" class="back-link">← Back to Main Site</a>
  
  <h1 class="main-title">LispBM vs Scheme R5RS: Quasiquotation Comparison</h1>
  
  <!-- Main Content Area -->
  <div id="mainContent">

    <p>Implementing quasiquotation (qq) is challenging! The implementation of qq in LispBM is based on Bawden&#39;s paper <a href="https://www.brics.dk/NS/99/1/BRICS-NS-99-1.pdf#page=6">Quasiquotation in Lisp</a>.
      To understand the algorithms from Bawden&#39;s appendix and to turn them into continuation passing style C code took a lot of effort! The correctness of the implementation
      is a big concern of mine.
    </p>
    
    <p>This page compares LispBM&#39;s quasiquote expansion with Guile 3 as a way to explore similarities and differences and
      to, perhaps, gain some confidence that LispBM quasiquotation is OK and useful.
    </p>

    <p> A comparison to a more standard Scheme is also useful for people with that experience if at some point they
      would want to write a LispBM program. </p> 
    
    <h2>Overview of Quasiquotation</h2>
    <p>Quasiquotation allows you to create templates where most of the structure is quoted (literal), but specific parts can be unquoted for evaluation. The three main constructs are:</p>
    <ul>
      <li><code>`</code> (quasiquote) - Creates a template.</li>
      <li><code>,</code> (unquote) - Evaluates an expression within the template.</li>
      <li><code>,@</code> (unquote-splicing) - Evaluates and splices a list into the template.</li>
    </ul>

    <h2>Quasiquotation Examples</h2>

    <p>
      The examples below compare quasiquotation expansion between LispBM and Guile.
      In the cases where a quasiquoted expression expands identically between LispBM and Guile, the background
      will be green. Sometimes the quasiquoted expression expands differently in LispBM and Guile. In these cases we follow up with a
      comparison of evaluating the two expressions. If two expressions are identical after evaluation
      the background will be blue and LispBM and Guile will be considered to semantically be identical in their handling
      of that expression. If the results differ both in expansion and after evaluation, the background is red.
    </p>

    <div style="margin: 20px 0;">
      <div style="display: inline-block; padding: 5px 10px; margin: 5px; background-color: var(--match-color); border-radius: 3px;">
        <strong>Green:</strong> Exact Match - Both systems produce identical results
      </div>
      <div style="display: inline-block; padding: 5px 10px; margin: 5px; background-color: var(--semantic-match-color); border-radius: 3px;">
        <strong>Blue:</strong> Semantic Match - Different syntax but equivalent when evaluated
      </div>
      <div style="display: inline-block; padding: 5px 10px; margin: 5px; background-color: var(--differ-color); border-radius: 3px;">
        <strong>Red:</strong> Difference - Results differ in behavior or evaluation
      </div>
    </div>

    <table style="width: 100%; border-collapse: collapse; margin: 20px 0;">
      <thead>
        <tr>
          <th style="border: 1px solid #ddd; padding: 15px; background-color: var(--lispbm-header-color); color: #ffffff; text-align: left; width: 50%;">LispBM</th>
          <th style="border: 1px solid #ddd; padding: 15px; background-color: var(--guile-header-color); color: #ffffff; text-align: left; width: 50%;">Guile 3 (Scheme R5RS)</th>
        </tr>
      </thead>
      <tbody>
        <!-- Test 1: MATCH -->
        <tr style="background-color: var(--match-color);">
          <td style="border: 1px solid #ddd; padding: 10px; vertical-align: top;">
            <pre style="margin: 0 !important;">`(,@(list 1 2 3))
; Result: (1 2 3)</pre>
          </td>
          <td style="border: 1px solid #ddd; padding: 10px; vertical-align: top;">
            <pre style="margin: 0 !important;">`(,@(list 1 2 3))
; Result: (1 2 3)</pre>
          </td>
        </tr>
        <!-- Test 2: MATCH -->
        <tr style="background-color: var(--match-color);">
          <td style="border: 1px solid #ddd; padding: 10px; vertical-align: top;">
            <pre style="margin: 0 !important;">`(a ,@(list 1 2) b)
; Result: (a 1 2 b)</pre>
          </td>
          <td style="border: 1px solid #ddd; padding: 10px; vertical-align: top;">
            <pre style="margin: 0 !important;">`(a ,@(list 1 2) b)
; Result: (a 1 2 b)</pre>
          </td>
        </tr>
        <!-- Test 3: DIFFER -->
        <tr style="background-color: var(--differ-color);">
          <td style="border: 1px solid #ddd; padding: 10px; vertical-align: top;">
            <pre style="margin: 0 !important;">`(,@())
; Result: nil</pre>
          </td>
          <td style="border: 1px solid #ddd; padding: 10px; vertical-align: top;">
            <pre style="margin: 0 !important;">`(,@())
; Result: ERROR or unsupported</pre>
          </td>
        </tr>
        <!-- Test 4: MATCH -->
        <tr style="background-color: var(--match-color);">
          <td style="border: 1px solid #ddd; padding: 10px; vertical-align: top;">
            <pre style="margin: 0 !important;">`(1 ,@(list 2 3) 4)
; Result: (1 2 3 4)</pre>
          </td>
          <td style="border: 1px solid #ddd; padding: 10px; vertical-align: top;">
            <pre style="margin: 0 !important;">`(1 ,@(list 2 3) 4)
; Result: (1 2 3 4)</pre>
          </td>
        </tr>
        <!-- Test 5: SEMANTIC MATCH -->
        <tr style="background-color: var(--semantic-match-color);">
          <td style="border: 1px solid #ddd; padding: 10px; vertical-align: top;">
            <pre style="margin: 0 !important;">``(a ,,(+ 1 2))
; Result: (append (quote (a)) (list 3))
; Eval: (a 3)</pre>
          </td>
          <td style="border: 1px solid #ddd; padding: 10px; vertical-align: top;">
            <pre style="margin: 0 !important;">``(a ,,(+ 1 2))
; Result: (quasiquote (a (unquote 3)))
; Eval: (a 3)</pre>
          </td>
        </tr>
        <!-- Test 6: MATCH -->
        <tr style="background-color: var(--match-color);">
          <td style="border: 1px solid #ddd; padding: 10px; vertical-align: top;">
            <pre style="margin: 0 !important;">`(quote ,@(list 1 2))
; Result: (quote 1 2)</pre>
          </td>
          <td style="border: 1px solid #ddd; padding: 10px; vertical-align: top;">
            <pre style="margin: 0 !important;">`(quote ,@(list 1 2))
; Result: (quote 1 2)</pre>
          </td>
        </tr>
        <!-- Test 7: MATCH -->
        <tr style="background-color: var(--match-color);">
          <td style="border: 1px solid #ddd; padding: 10px; vertical-align: top;">
            <pre style="margin: 0 !important;">`(,@(cdr (quote (0 1 2 3))))
; Result: (1 2 3)</pre>
          </td>
          <td style="border: 1px solid #ddd; padding: 10px; vertical-align: top;">
            <pre style="margin: 0 !important;">`(,@(cdr (quote (0 1 2 3))))
; Result: (1 2 3)</pre>
          </td>
        </tr>
        <!-- Test 8: MATCH -->
        <tr style="background-color: var(--match-color);">
          <td style="border: 1px solid #ddd; padding: 10px; vertical-align: top;">
            <pre style="margin: 0 !important;">`(list ,@(list 1 2 3))
; Result: (list 1 2 3)</pre>
          </td>
          <td style="border: 1px solid #ddd; padding: 10px; vertical-align: top;">
            <pre style="margin: 0 !important;">`(list ,@(list 1 2 3))
; Result: (list 1 2 3)</pre>
          </td>
        </tr>
        <!-- Test 9: MATCH -->
        <tr style="background-color: var(--match-color);">
          <td style="border: 1px solid #ddd; padding: 10px; vertical-align: top;">
            <pre style="margin: 0 !important;">`,'a
; Result: a</pre>
          </td>
          <td style="border: 1px solid #ddd; padding: 10px; vertical-align: top;">
            <pre style="margin: 0 !important;">`,'a
; Result: a</pre>
          </td>
        </tr>
        <!-- Test 10: SEMANTIC MATCH -->
        <tr style="background-color: var(--semantic-match-color);">
          <td style="border: 1px solid #ddd; padding: 10px; vertical-align: top;">
            <pre style="margin: 0 !important;">``,a
; Result: a
; Eval: variable_not_bound</pre>
          </td>
          <td style="border: 1px solid #ddd; padding: 10px; vertical-align: top;">
            <pre style="margin: 0 !important;">``,a
; Result: (quasiquote (unquote a))
; Eval: Unbound variable: a</pre>
          </td>
        </tr>
        <!-- Test 11: MATCH -->
        <tr style="background-color: var(--match-color);">
          <td style="border: 1px solid #ddd; padding: 10px; vertical-align: top;">
            <pre style="margin: 0 !important;">`,`a
; Result: a</pre>
          </td>
          <td style="border: 1px solid #ddd; padding: 10px; vertical-align: top;">
            <pre style="margin: 0 !important;">`,`a
; Result: a</pre>
          </td>
        </tr>
        <!-- Test 12: MATCH -->
        <tr style="background-color: var(--match-color);">
          <td style="border: 1px solid #ddd; padding: 10px; vertical-align: top;">
            <pre style="margin: 0 !important;">`(1 . 2)
; Result: (1 . 2)</pre>
          </td>
          <td style="border: 1px solid #ddd; padding: 10px; vertical-align: top;">
            <pre style="margin: 0 !important;">`(1 . 2)
; Result: (1 . 2)</pre>
          </td>
        </tr>
        <!-- Test 13: DIFFER -->
        <tr style="background-color: var(--differ-color);">
          <td style="border: 1px solid #ddd; padding: 10px; vertical-align: top;">
            <pre style="margin: 0 !important;">`',(car ())
; Result: (quote nil)</pre>
          </td>
          <td style="border: 1px solid #ddd; padding: 10px; vertical-align: top;">
            <pre style="margin: 0 !important;">`',(car ())
; Result: ERROR or unsupported</pre>
          </td>
        </tr>
        <!-- Test 14: MATCH -->
        <tr style="background-color: var(--match-color);">
          <td style="border: 1px solid #ddd; padding: 10px; vertical-align: top;">
            <pre style="margin: 0 !important;">`(,1 ,2 . ,3)
; Result: (1 2 . 3)</pre>
          </td>
          <td style="border: 1px solid #ddd; padding: 10px; vertical-align: top;">
            <pre style="margin: 0 !important;">`(,1 ,2 . ,3)
; Result: (1 2 . 3)</pre>
          </td>
        </tr>
        <!-- Test 15: DIFFER -->
        <tr style="background-color: var(--differ-color);">
          <td style="border: 1px solid #ddd; padding: 10px; vertical-align: top;">
            <pre style="margin: 0 !important;">`(,@nil ,1)
; Result: (1)</pre>
          </td>
          <td style="border: 1px solid #ddd; padding: 10px; vertical-align: top;">
            <pre style="margin: 0 !important;">`(,@nil ,1)
; Result: ERROR or unsupported</pre>
          </td>
        </tr>
        <!-- Test 16: DIFFER -->
        <tr style="background-color: var(--differ-color);">
          <td style="border: 1px solid #ddd; padding: 10px; vertical-align: top;">
            <pre style="margin: 0 !important;">`(1 2 ,@() ,@() 3)
; Result: (1 2 3)</pre>
          </td>
          <td style="border: 1px solid #ddd; padding: 10px; vertical-align: top;">
            <pre style="margin: 0 !important;">`(1 2 ,@() ,@() 3)
; Result: ERROR or unsupported</pre>
          </td>
        </tr>
        <!-- Test 17: SEMANTIC MATCH -->
        <tr style="background-color: var(--semantic-match-color);">
          <td style="border: 1px solid #ddd; padding: 10px; vertical-align: top;">
            <pre style="margin: 0 !important;">``(,,@(list 0 1 2))
; Result: (list 0 1 2)
; Eval: (0 1 2)</pre>
          </td>
          <td style="border: 1px solid #ddd; padding: 10px; vertical-align: top;">
            <pre style="margin: 0 !important;">``(,,@(list 0 1 2))
; Result: (quasiquote ((unquote 0 1 2)))
; Eval: (0 1 2)</pre>
          </td>
        </tr>
        <!-- Test 18: SEMANTIC MATCH -->
        <tr style="background-color: #99ccff;">
          <td style="border: 1px solid #ddd; padding: 10px; vertical-align: top;">
            <pre style="margin: 0 !important;">``(,,@(cdr '(0 1 2 3)) ,4)
; Result: (append (list 1 2 3) (list 4))
; Eval: (1 2 3 4)</pre>
          </td>
          <td style="border: 1px solid #ddd; padding: 10px; vertical-align: top;">
            <pre style="margin: 0 !important;">``(,,@(cdr '(0 1 2 3)) ,4)
; Result: (quasiquote ((unquote 1 2 3) (unquote 4)))
; Eval: (1 2 3 4)</pre>
          </td>
        </tr>
        <!-- Test 19: DIFFER -->
        <tr style="background-color: var(--differ-color);">
          <td style="border: 1px solid #ddd; padding: 10px; vertical-align: top;">
            <pre style="margin: 0 !important;">``(1 2 ,,@() ,,@())
; Result: (append (quote (1 2)) (list) (list))</pre>
          </td>
          <td style="border: 1px solid #ddd; padding: 10px; vertical-align: top;">
            <pre style="margin: 0 !important;">``(1 2 ,,@() ,,@())
; Result: ERROR or unsupported</pre>
          </td>
        </tr>
        <!-- Test 20: SEMANTIC MATCH -->
        <tr style="background-color: var(--semantic-match-color);">
          <td style="border: 1px solid #ddd; padding: 10px; vertical-align: top;">
            <pre style="margin: 0 !important;">``(a ,,(+ 1 2) ,(+ 3 4))
; Result: (append (quote (a)) (list 3) (list (+ 3 4)))
; Eval: (a 3 7)</pre>
          </td>
          <td style="border: 1px solid #ddd; padding: 10px; vertical-align: top;">
            <pre style="margin: 0 !important;">``(a ,,(+ 1 2) ,(+ 3 4))
; Result: (quasiquote (a (unquote 3) (unquote (+ 3 4))))
; Eval: (a 3 7)</pre>
          </td>
        </tr>
        <!-- Test 21: MATCH -->
        <tr style="background-color: var(--match-color);">
          <td style="border: 1px solid #ddd; padding: 10px; vertical-align: top;">
            <pre style="margin: 0 !important;">`5
; Result: 5</pre>
          </td>
          <td style="border: 1px solid #ddd; padding: 10px; vertical-align: top;">
            <pre style="margin: 0 !important;">`5
; Result: 5</pre>
          </td>
        </tr>
        <!-- Test 22: MATCH -->
        <tr style="background-color: var(--match-color);">
          <td style="border: 1px solid #ddd; padding: 10px; vertical-align: top;">
            <pre style="margin: 0 !important;">`,5
; Result: 5</pre>
          </td>
          <td style="border: 1px solid #ddd; padding: 10px; vertical-align: top;">
            <pre style="margin: 0 !important;">`,5
; Result: 5</pre>
          </td>
        </tr>
        <!-- Test 23: SEMANTIC MATCH -->
        <tr style="background-color: var(--semantic-match-color);">
          <td style="border: 1px solid #ddd; padding: 10px; vertical-align: top;">
            <pre style="margin: 0 !important;">(let ((x 5)) `(let ((x ,(+ x 10))) `(list ,,x ,x)))
; Result: (let ((x 15)) (append (quote (list)) (list 5) (list x)))
; Eval: (list 5 15)</pre>
          </td>
          <td style="border: 1px solid #ddd; padding: 10px; vertical-align: top;">
            <pre style="margin: 0 !important;">(let ((x 5)) `(let ((x ,(+ x 10))) `(list ,,x ,x)))
; Result: (let ((x 15)) (quasiquote (list (unquote 5) (unquote x))))
; Eval: (list 5 15)</pre>
          </td>
        </tr>
        <!-- Test 24: DIFFER -->
        <tr style="background-color: var(--differ-color);">
          <td style="border: 1px solid #ddd; padding: 10px; vertical-align: top;">
            <pre style="margin: 0 !important;">`,@0
; Result: read_error
; Eval: read_error</pre>
          </td>
          <td style="border: 1px solid #ddd; padding: 10px; vertical-align: top;">
            <pre style="margin: 0 !important;">`,@0
; Result: (unquote-splicing 0)
; Eval: ERROR</pre>
          </td>
        </tr>
        <!-- Test 25: MATCH -->
        <tr style="background-color: var(--match-color);">
          <td style="border: 1px solid #ddd; padding: 10px; vertical-align: top;">
            <pre style="margin: 0 !important;">`(1 2 ,@'(3 . 4))
; Result: (1 2 3 . 4)</pre>
          </td>
          <td style="border: 1px solid #ddd; padding: 10px; vertical-align: top;">
            <pre style="margin: 0 !important;">`(1 2 ,@'(3 . 4))
; Result: (1 2 3 . 4)</pre>
          </td>
        </tr>
        <!-- Test 26: MATCH -->
        <tr style="background-color: var(--match-color);">
          <td style="border: 1px solid #ddd; padding: 10px; vertical-align: top;">
            <pre style="margin: 0 !important;">`(1 2 ,@(list 3 4 5) ,@(list 6 7 8) 9 10)
; Result: (1 2 3 4 5 6 7 8 9 10)</pre>
          </td>
          <td style="border: 1px solid #ddd; padding: 10px; vertical-align: top;">
            <pre style="margin: 0 !important;">`(1 2 ,@(list 3 4 5) ,@(list 6 7 8) 9 10)
; Result: (1 2 3 4 5 6 7 8 9 10)</pre>
          </td>
        </tr>
        <!-- Test 27: MATCH -->
        <tr style="background-color: var(--match-color);">
          <td style="border: 1px solid #ddd; padding: 10px; vertical-align: top;">
            <pre style="margin: 0 !important;">`(1 2 ,@'() ,@'() 3)
; Result: (1 2 3)</pre>
          </td>
          <td style="border: 1px solid #ddd; padding: 10px; vertical-align: top;">
            <pre style="margin: 0 !important;">`(1 2 ,@'() ,@'() 3)
; Result: (1 2 3)</pre>
          </td>
        </tr>
        <!-- Test 28: SEMANTIC MATCH -->
        <tr style="background-color: var(--semantic-match-color);">
          <td style="border: 1px solid #ddd; padding: 10px; vertical-align: top;">
            <pre style="margin: 0 !important;">``(1 2 ,,@'() ,,@'())
; Result: (append (quote (1 2)) (list) (list))
; Eval:  (1 2)</pre>
          </td>
          <td style="border: 1px solid #ddd; padding: 10px; vertical-align: top;">
            <pre style="margin: 0 !important;">``(1 2 ,,@'() ,,@'())
; Result: (quasiquote (1 2 (unquote) (unquote)))
; Eval: (1 2)</pre>
          </td>
        </tr>

      </tbody>
    </table>
 
    <h2>Important note about nil</h2> 

    <p>Guile does not have a nil so some of the comparisons above are a bit unfair.
      Look at the example below that in Guile is an error because nil is not
      defined by default:
    </p>
    
    <pre>
`(,@nil ,1)
Unbound variable: nil
    </pre>
    
    <p>
      If we define nil to be the empty list in guile then the following happens:
    </p>
    
    <pre>
(define nil '())
scheme@(guile-user) [5]> `(,@nil ,1)
$1 = (1)
    </pre>
    
    <p>
      So in that case it behaves the same as LispBM. So let's try one more thing:
    </p>
    
    <pre>
`(,@() ,1) 
While compiling expression:
Syntax error:
unknown location: unexpected syntax in form ()
    </pre>

    <p> Here we get an error again.
      Let's try one more thing in guile:
    </p>

    <pre>
`(,@'() ,1)
 $2 = (1)
    </pre>

    <p>
      In this final case Guile and LispBM behave exactly the same again. 
    </p>


    <h2>Deeply nested quasiquotes</h2>

    <p>
      Example: <code>`(list 1 `(,@(list 1 2 3) `(,@(list 4 5 6))))</code>
    </p>
    
    <p>
      The example above is an expression with deeply nested quasiquotes. These do not fit
      the pattern used in the tests above where either the quasiquote expands equally in LispBM and Guile
      or we check if they are Semantically equivalent after one round of evaluation.
    </p>

    <p>
      In this case we would need to traverse into the result and evaluate subtrees then test
      equality of value.
    </p>

    <p>
      LispBM expands the example as follows: <code>(list 1 (append (list 1 2 3) (list (quote (list 4 5 6)))))</code>.
    </p>

    <p>
      Guile expands the same example as: <code>(list 1 (quasiquote ((unquote-splicing (list 1 2 3)) (quasiquote ((unquote-splicing (list 4 5 6)))))))</code>
    </p> 

    <p>
      After one round of LispBM evaluation: <code>(1 (1 2 3 (list 4 5 6)))</code>
    </p>

    <p>
      After one round of Guile evaluation: <code>(1 (1 2 3 (quasiquote ((unquote-splicing (list 4 5 6))))))</code>
    </p>

    <p>
      The two final expressions are semantically equivalent because in LispBM <code>(list 4 5 6)</code> evaluates to <code>(4 5 6)</code> and
      in Guile <code>(quasiquote ((unquote-splicing (list 4 5 6))))</code> also evaluates to <code>(4 5 6)</code>.
    </p>
    
    <h2>LispBM Arrays vs Guile Vectors in Quasiquotation</h2>
    
    <p>
      Another difference between LispBM and Guile is how they handle array/vector data structures 
      within quasiquotation contexts. Both languages have array-like structures, but they integrate 
      differently with the quasiquote system.
    </p>
    
    <h3>Guile Vectors with Quasiquotation</h3>
    <p>
      Guile has vectors with literal syntax <code>#(...)</code> that integrates seamlessly with quasiquotation.
      As I understand it, the <code>#</code> can be thought of as a <code>'</code> for vectors.
    </p> <!-- ' --> 
    
    <pre>
;; Literal vector (no evaluation)
#(1 2 (+ 1 2))          ; → #(1 2 (+ 1 2))

;; Vector with quasiquote (selective evaluation)  
`#(,(+ 1 2) 4)          ; → #(3 4)

;; Vector constructor (full evaluation)
(vector (+ 1 2) 4)      ; → #(3 4)
    </pre>
    
    <h3>LispBM Arrays with Quasiquotation</h3>
    <p>
      LispBM has arrays with literal syntax <code>[| ... |]</code> that are always literal, 
      regardless of quasiquote context:
    </p>
    
    <pre>
;; Literal array (no evaluation)
[| 1 2 (+ 1 2) |]       ; → [| 1 2 (+ 1 2) |]

;; Array in quasiquote (still no evaluation!)
`[| ,(+ 1 2) 4 |]       ; → [|([comma] (+ 1 2)) 4|]

;; Array constructor (full evaluation)
`(array ,(+ 1 2) 4)     ; → (array 3 4), which evaluates to an array
    </pre>

    <p>
      The example where <code>`[| ,(+ 1 2) 4 |]</code> becomes <code>[|([comma] (+ 1 2)) 4|]</code>
      is unfortunate. The <code>[comma]</code> is how LispBM prints the comma symbol, and this
      internal symbol should not be a part of any fully parsed expression. This is
      an example of where an internal implementation detail is leaking out and becomes visible to the
      user. This will be fixed by in a future version of LispBM.
    </p> 
    
    <h3>Explanation</h3>
    <p>
      LispBM is meant for systems with very limited ram and uses different memory regions for cons-cell heap
      and for more array like data (array-memory). The literal syntax for arrays <code>[| ... |]</code>, is processed
      entirely in the reader and the array can be allocated and filled with data without any involvement of
      the evaluator. To allow the comma <code>,</code> and comma-at <code>,@</code> operations inside of an
          <code>[| ... |]</code> array would mean that the actual array in array-memory cannot be created
          until evaluation time and the data will be intermediately stored on the heap as well as on the evaluation stack.
    </p>

    <p>
      The chosen approach means that arrays specified using <code>[| ... |]</code> can be larger than
      the evaluation stack as well as larger than the available cons-cell heap even.
    </p>

    <p>
      Note that the <code>[ ... ]</code> byte array syntax in LispBM is also entirely
      literal for the exact same reasons.
    </p> 
    
    <h2>Conclusion</h2>

    <p>
      There are differences but I am not sure these are very important. LispBM seems to handle these cases
      of quasiquotation perfectly fine.
    </p>

    <p>
      If you have examples of interesting quasiquotes please send me a message. I would love
      to expand on this comparison and to explore the limits of the quasiquoter.
      If we are lucky we find some bugs (hopefully fixable) along the way!
    </p>

    
    
  </div>
</div>

<script>
  // Add syntax highlighting or interactive features if needed
</script>

</body>
</html>
